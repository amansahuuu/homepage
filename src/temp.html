<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Image Color Extraction</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
        background-color: #f5f5f5;
      }

      .container {
        background: white;
        padding: 30px;
        border-radius: 10px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }

      .upload-area {
        border: 2px dashed #ccc;
        border-radius: 10px;
        padding: 40px;
        text-align: center;
        margin-bottom: 20px;
        cursor: pointer;
        transition: border-color 0.3s;
      }

      .upload-area:hover {
        border-color: #007bff;
      }

      .upload-area.dragover {
        border-color: #007bff;
        background-color: #f0f8ff;
      }

      .image-preview {
        max-width: 300px;
        max-height: 300px;
        margin: 20px auto;
        display: block;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }

      .results {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 20px;
        margin-top: 20px;
      }

      .result-item {
        background: #f8f9fa;
        padding: 15px;
        border-radius: 8px;
        text-align: center;
      }

      .color-box {
        width: 100px;
        height: 100px;
        margin: 10px auto;
        border-radius: 8px;
        border: 1px solid #ddd;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .color-info {
        font-family: monospace;
        font-size: 14px;
        margin-top: 10px;
      }

      .method-title {
        font-weight: bold;
        margin-bottom: 10px;
        color: #333;
      }

      input[type="file"] {
        display: none;
      }

      .btn {
        background: #007bff;
        color: white;
        padding: 10px 20px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        margin: 5px;
      }

      .btn:hover {
        background: #0056b3;
      }

      .palette {
        display: flex;
        justify-content: center;
        gap: 5px;
        margin-top: 10px;
      }

      .palette-color {
        width: 30px;
        height: 30px;
        border-radius: 4px;
        border: 1px solid #ddd;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Image Color Extraction</h1>
      <p>
        Upload an image to extract its dominant colors using different
        algorithms
      </p>

      <div
        class="upload-area"
        onclick="document.getElementById('imageInput').click()"
      >
        <div>
          <p>üìÅ Click here to upload an image</p>
          <p style="color: #666; font-size: 14px">
            or drag and drop an image file
          </p>
        </div>
      </div>

      <input type="file" id="imageInput" accept="image/*" />

      <div id="imageContainer" style="display: none">
        <img id="previewImage" class="image-preview" alt="Preview" />
        <div style="text-align: center; margin: 20px 0">
          <button class="btn" onclick="extractColors()">Extract Colors</button>
        </div>
      </div>

      <div id="results" class="results"></div>
    </div>

    <script>
      // Method 1: Simple Average Color
      function getAverageColor(imageData) {
        const data = imageData.data;
        let r = 0,
          g = 0,
          b = 0;
        const pixelCount = data.length / 4;

        for (let i = 0; i < data.length; i += 4) {
          r += data[i];
          g += data[i + 1];
          b += data[i + 2];
        }

        return {
          r: Math.round(r / pixelCount),
          g: Math.round(g / pixelCount),
          b: Math.round(b / pixelCount),
        };
      }

      // Method 2: Most Frequent Color (Color Quantization)
      function getMostFrequentColor(imageData) {
        const data = imageData.data;
        const colorCount = {};

        // Reduce color precision to group similar colors
        const precision = 32; // Higher = more precise, lower = more grouping

        for (let i = 0; i < data.length; i += 4) {
          const r = Math.floor(data[i] / precision) * precision;
          const g = Math.floor(data[i + 1] / precision) * precision;
          const b = Math.floor(data[i + 2] / precision) * precision;
          const alpha = data[i + 3];

          // Skip transparent pixels
          if (alpha < 128) continue;

          const color = `${r},${g},${b}`;
          colorCount[color] = (colorCount[color] || 0) + 1;
        }

        // Find most frequent color
        let maxCount = 0;
        let dominantColor = "0,0,0";

        for (const color in colorCount) {
          if (colorCount[color] > maxCount) {
            maxCount = colorCount[color];
            dominantColor = color;
          }
        }

        const [r, g, b] = dominantColor.split(",").map(Number);
        return { r, g, b };
      }

      // Method 3: K-Means Clustering (Simplified)
      function getKMeansColor(imageData, k = 5) {
        const data = imageData.data;
        const pixels = [];

        // Sample pixels (every 10th pixel for performance)
        for (let i = 0; i < data.length; i += 40) {
          if (data[i + 3] > 128) {
            // Skip transparent
            pixels.push([data[i], data[i + 1], data[i + 2]]);
          }
        }

        if (pixels.length === 0) return { r: 0, g: 0, b: 0 };

        // Initialize centroids randomly
        const centroids = [];
        for (let i = 0; i < k; i++) {
          const randomPixel = pixels[Math.floor(Math.random() * pixels.length)];
          centroids.push([...randomPixel]);
        }

        // K-means iterations
        for (let iter = 0; iter < 10; iter++) {
          const clusters = Array(k)
            .fill()
            .map(() => []);

          // Assign pixels to nearest centroid
          pixels.forEach((pixel) => {
            let minDistance = Infinity;
            let clusterIndex = 0;

            centroids.forEach((centroid, i) => {
              const distance = Math.sqrt(
                Math.pow(pixel[0] - centroid[0], 2) +
                  Math.pow(pixel[1] - centroid[1], 2) +
                  Math.pow(pixel[2] - centroid[2], 2)
              );

              if (distance < minDistance) {
                minDistance = distance;
                clusterIndex = i;
              }
            });

            clusters[clusterIndex].push(pixel);
          });

          // Update centroids
          centroids.forEach((centroid, i) => {
            if (clusters[i].length > 0) {
              centroid[0] =
                clusters[i].reduce((sum, p) => sum + p[0], 0) /
                clusters[i].length;
              centroid[1] =
                clusters[i].reduce((sum, p) => sum + p[1], 0) /
                clusters[i].length;
              centroid[2] =
                clusters[i].reduce((sum, p) => sum + p[2], 0) /
                clusters[i].length;
            }
          });
        }

        // Find largest cluster
        let largestCluster = 0;
        let maxSize = 0;

        centroids.forEach((centroid, i) => {
          const clusterSize = pixels.filter((pixel) => {
            const distances = centroids.map((c) =>
              Math.sqrt(
                Math.pow(pixel[0] - c[0], 2) +
                  Math.pow(pixel[1] - c[1], 2) +
                  Math.pow(pixel[2] - c[2], 2)
              )
            );
            return distances.indexOf(Math.min(...distances)) === i;
          }).length;

          if (clusterSize > maxSize) {
            maxSize = clusterSize;
            largestCluster = i;
          }
        });

        const dominant = centroids[largestCluster];
        return {
          r: Math.round(dominant[0]),
          g: Math.round(dominant[1]),
          b: Math.round(dominant[2]),
        };
      }

      // Method 4: Color Palette Extraction
      function getColorPalette(imageData, count = 5) {
        const data = imageData.data;
        const pixels = [];

        // Sample pixels
        for (let i = 0; i < data.length; i += 16) {
          if (data[i + 3] > 128) {
            pixels.push([data[i], data[i + 1], data[i + 2]]);
          }
        }

        // Simple clustering
        const palette = [];
        const used = new Set();

        while (palette.length < count && palette.length < pixels.length) {
          let bestPixel = null;
          let maxDistance = 0;

          pixels.forEach((pixel, index) => {
            if (used.has(index)) return;

            let minDistanceToExisting = Infinity;
            palette.forEach((existing) => {
              const distance = Math.sqrt(
                Math.pow(pixel[0] - existing.r, 2) +
                  Math.pow(pixel[1] - existing.g, 2) +
                  Math.pow(pixel[2] - existing.b, 2)
              );
              minDistanceToExisting = Math.min(minDistanceToExisting, distance);
            });

            if (palette.length === 0 || minDistanceToExisting > maxDistance) {
              maxDistance = minDistanceToExisting;
              bestPixel = { pixel, index };
            }
          });

          if (bestPixel) {
            palette.push({
              r: bestPixel.pixel[0],
              g: bestPixel.pixel[1],
              b: bestPixel.pixel[2],
            });
            used.add(bestPixel.index);
          }
        }

        return palette;
      }

      // Utility functions
      function rgbToHex(r, g, b) {
        return (
          "#" +
          [r, g, b]
            .map((x) => {
              const hex = x.toString(16);
              return hex.length === 1 ? "0" + hex : hex;
            })
            .join("")
        );
      }

      function getImageData(img) {
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");

        canvas.width = img.width;
        canvas.height = img.height;

        ctx.drawImage(img, 0, 0);
        return ctx.getImageData(0, 0, canvas.width, canvas.height);
      }

      // Main extraction function
      function extractColors() {
        const img = document.getElementById("previewImage");
        const imageData = getImageData(img);

        // Extract colors using different methods
        const averageColor = getAverageColor(imageData);
        const frequentColor = getMostFrequentColor(imageData);
        const kmeansColor = getKMeansColor(imageData);
        const palette = getColorPalette(imageData);

        // Display results
        displayResults([
          { title: "Average Color", color: averageColor },
          { title: "Most Frequent", color: frequentColor },
          { title: "K-Means Dominant", color: kmeansColor },
          { title: "Color Palette", color: palette[0], palette: palette },
        ]);
      }

      function displayResults(results) {
        const resultsDiv = document.getElementById("results");
        resultsDiv.innerHTML = "";

        results.forEach((result) => {
          const div = document.createElement("div");
          div.className = "result-item";

          const color = result.color;
          const hex = rgbToHex(color.r, color.g, color.b);

          div.innerHTML = `
                    <div class="method-title">${result.title}</div>
                    <div class="color-box" style="background-color: ${hex}"></div>
                    <div class="color-info">
                        <div>RGB: ${color.r}, ${color.g}, ${color.b}</div>
                        <div>HEX: ${hex}</div>
                    </div>
                    ${
                      result.palette
                        ? `
                        <div class="palette">
                            ${result.palette
                              .map(
                                (c) =>
                                  `<div class="palette-color" style="background-color: ${rgbToHex(
                                    c.r,
                                    c.g,
                                    c.b
                                  )}" title="${rgbToHex(c.r, c.g, c.b)}"></div>`
                              )
                              .join("")}
                        </div>
                    `
                        : ""
                    }
                `;

          resultsDiv.appendChild(div);
        });
      }

      // File handling
      document
        .getElementById("imageInput")
        .addEventListener("change", function (e) {
          const file = e.target.files[0];
          if (file) {
            const reader = new FileReader();
            reader.onload = function (e) {
              const img = document.getElementById("previewImage");
              img.src = e.target.result;
              img.onload = function () {
                document.getElementById("imageContainer").style.display =
                  "block";
              };
            };
            reader.readAsDataURL(file);
          }
        });

      // Drag and drop
      const uploadArea = document.querySelector(".upload-area");

      ["dragenter", "dragover", "dragleave", "drop"].forEach((eventName) => {
        uploadArea.addEventListener(eventName, preventDefaults, false);
      });

      function preventDefaults(e) {
        e.preventDefault();
        e.stopPropagation();
      }

      ["dragenter", "dragover"].forEach((eventName) => {
        uploadArea.addEventListener(eventName, highlight, false);
      });

      ["dragleave", "drop"].forEach((eventName) => {
        uploadArea.addEventListener(eventName, unhighlight, false);
      });

      function highlight(e) {
        uploadArea.classList.add("dragover");
      }

      function unhighlight(e) {
        uploadArea.classList.remove("dragover");
      }

      uploadArea.addEventListener("drop", handleDrop, false);

      function handleDrop(e) {
        const dt = e.dataTransfer;
        const files = dt.files;

        if (files.length > 0) {
          document.getElementById("imageInput").files = files;
          document
            .getElementById("imageInput")
            .dispatchEvent(new Event("change"));
        }
      }

      // Standalone function for external use
      function getDominantColor(imageElement, method = "kmeans") {
        const imageData = getImageData(imageElement);

        switch (method) {
          case "average":
            return getAverageColor(imageData);
          case "frequent":
            return getMostFrequentColor(imageData);
          case "kmeans":
          default:
            return getKMeansColor(imageData);
        }
      }

      // Export functions for external use
      window.getDominantColor = getDominantColor;
      window.getColorPalette = getColorPalette;
      window.rgbToHex = rgbToHex;
    </script>
  </body>
</html>
